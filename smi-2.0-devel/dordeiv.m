 function [Sn,R]  =  dordeiv(u,y,r,i,R); 
  
% dordeiv  is a preprocessor function that extracts the column-space of 
%          the extended observability matrix from input/output data. 
%      Data from different experiments can be concatenated using 
%      the extra input argument Z. The estimated column-space is 
%      used in the function destac to extract the matrices A and C. 
%      This function implements the errors-in-variables moesp 
%      algorithm which can be used for the  errors-in-variables 
%      identification problem. 
%          Model structure: 
%             x(k+1)  = Ax(k) + Bu~(k) + f(k) 
%             y~(k)   = Cx(k) + Du~(k) 
%          with measurements 
%             u(k) = u~(k) + w(k) 
%             y(k) = y~(k) + v(k) 
%          where f(k), w(k) and v(k) are zero-mean white noise sequences 
%          independent of the input u~(j) for k >= j. 
%          The system can be operated under either open-loop or closed-loop. 
%          For closed-loop operation, r(k) is an external reference input. 
%          For open-loop operation, where u~(k)is white noise dordpo ... 
%     will give better results. 
% 
% Syntax: 
%          [Sn,R,Z]=dordeiv(u,y,r,i,Zold) 
%          [Sn,R,Z]=dordeiv(u,y,[],i,Zold) 
% 
% Input: 
%  u,y     The input and output data of the system to be identified 
%  r       Closed-loop reference input. 
%  i       The dimension parameter that determines the number 
%          of block rows in the processed Hankel matrices. 
%          This parameter should be chosen larger than the expected 
%          system order. The optimal value has to be found by trial 
%          and error. Generally twice as large is a good starting value. 
%  Zold    Matrix obtained from processing a previous 
%          data-batch with dordrs. 
% 
% Output: 
%  Sn      Singular values bearing information on the order 
%          of the system. 
%  R       Data structure used by destac for the estimation of A 
%          and C or by a next call to dordom. This matrix contains the 
%          triangular factor,  estimated column-space and additional 
%          information (such as i/o dimension etc.). 
%  Z       Matrix containing information on system which can be used by 
%          future calls of dordeiv. 
% 
% See also: dordom, dordpi, dordpo, dordrs, destac, destbd 
% 
 
%  --- This file is generated from the MWEB source dmoesp.web --- 
% 
% Reference: C.T. Chou and M. Verhaegen 
%            Subspace algorithms fpr the identification of 
%            multivariable dynamic errors-in-variables models 
%            Automatica, October, 1997 
 
% C.T. Chou, Oct 1997 
% copyright (c) 1997 C.T. Chou 
 
 
 
 if nargin==0 
  help dordeiv 
  return 
end 
argmin = 4;lmin = 1;mmin = 1; 
 if nargin<argmin 
  error('There are not enough arguments.') 
end 
 
 
 
 if size(y,2)>size(y,1) 
  y = y'; 
end 
if size(u,2)>size(u,1) 
  u = u'; 
end 
Ns = size(y,1); 
l = size(y,2); 
m = size(u,2); 
if (l<lmin), 
  error('It is required to have at least one output.') 
end 
if (m<mmin), 
  error('It is required to have at least one input.') 
elseif  (~(size(u,1)==Ns)&(m>0)) 
  error('The input and output must have same length.') 
end 
 
 
 
 if size(r,2)>size(r,1) 
  r = r'; 
end 
[Nr,nr] = size(r); 
if ~isempty(r) & ~(Nr==Ns) 
  error('The input and reference must have same length.') 
end 
 
 
 
Hheight = 2 * i * (m+l+nr);Hwidth = Ns-2 * i+1; 
 if i<1, 
  error('The blockmatrix parameter must be a positive number.') 
end 
if Hheight>Hwidth; 
  error('The block matrix parameter ''i'' is too large for this data length.') 
end 
 
 
if (nargin > argmin) 
   if isstruct(R) 
  if isfield(R,'L') 
    L = R.L; 
    if ~(all(size(L)==[Hheight,Hheight])) 
      error('R.L has unexpected size.') 
    end 
  else 
      error('The field R.L does not exist.') 
  end 
else 
  error('R should be a structure, generated by dordxx.') 
end 
 
 
else 
  L = []; 
end 
 
 
 
 
 %Hankel matrices 
N = Ns-2 * i+1; 
Y = zeros(N,2 * i * l); 
U = zeros(N,2 * i * m); 
E = zeros(N,i * nr); 
if isempty(r) 
  for k = (1:2 * i) 
    U(:,(k-1) * m+1:k * m) = u(k:N+k-1,:); 
    Y(:,(k-1) * l+1:k * l) = y(k:N+k-1,:); 
  end 
else 
  for k = (1:2 * i) 
    U(:,(k-1) * m+1:k * m) = u(k:N+k-1,:); 
    Y(:,(k-1) * l+1:k * l) = y(k:N+k-1,:); 
    E(:,(k-1) * m+1:k * m) = r(k:N+k-1,:); 
  end 
end 
upr  =  1:m * i; 
ufr  =  m * i+1:2 * m * i; 
ypr  =  1:l * i; 
yfr  =  l * i+1:2 * l * i; 
% Use the method from section 7 in the EIV paper 
Z  =  triu(qr([U(:,ufr) U(:,upr) Y(:,ypr) E Y(:,yfr); L])); 
Z  =  Z(1:Hheight,1:Hheight); 
Zx  =  Z'; 
F0  =  Zx([1:i * m i * 2 * m+i * l+2 * i * nr+1:Hheight],1:i * 2 * m+i * l+2 * i * nr); 
B0  =  Zx(i * m+1:i * 2 * m+i * l+2 * i * nr,1:i * 2 * m+i * l+2 * i * nr)'; 
% step 1: Nullify R33^N in B0 (different from paper) 
Q1  =  qr(B0); 
F1  =  F0 * Q1; 
F1  =  F1(:,1:(m+l) * i); 
% step 2: make F2 lower triangular 
F2  =  triu(qr(F1'))'; 
Lb  =  F2(m * i+1:(m+l) * i,m * i+1:(m+l) * i); 
L = Z; 
 
 
 % SVD 
[Un,Sn,Vn] = svd(Lb); 
Sn = diag(Sn); 
Sn = Sn(1:i); 
R = struct('L',L,'Un',Un,'m',m,'l',l,'i',i); 
 
 
 
 

