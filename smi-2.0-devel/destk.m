 function K = destk(A,B,C,D,R); 
  
% destk    Estimates the Kalman gain of a innovations model, 
%          when the matrices A and C are known. They can be 
%          estimated with the functions dordpo and destac. 
%          Model structure: 
%             x(k+1) = Ax(k) + Bu(k) + w(k) 
%             y(k)   = Cx(k) + Du(k) + v(k) 
%          where w(k), v(k) are zero-mean white noise sequences, 
%          independent of the noise-free input u(k). 
% 
% Syntax: 
%          K=destk(A,B,C,D,R) 
%          K=destk(A,C,R) 
% 
% Input 
% A,B,C,D  State space matrices (B and D are optional) 
% R        Data structure obtained from dordpo. This matrix contains 
%          compressed data needed to estimate the Kalman gain. 
%          This includes the lower triangular factor and additional 
%          information (such as i/o dimension etc.). 
% 
% Output: 
% K        Estimated Kalman gain. 
% 
% See also: dordpo, destac, destbd 
 
%  --- This file is generated from the MWEB source dmoesp.web --- 
% 
% Bert Haverkamp 12/11/99 
% Copyright (c) 1999 Bert Haverkamp 
 
 
 
 if nargin==0 
  help destk 
  return 
end 
if nargin==3 
  R = C;C = B;B = [];D = []; 
  end 
error(abcdchk(A,B,C,D)); 
n = size(A,1); 
 if ~isempty(R) 
  if ~isstruct(R) 
    error('R should be a stucture, generated by dordxx.') 
  end 
  if isfield(R,'m') 
    m = R.m; 
    if (m<0) 
      error('Illegal value for number of inputs in R.m') 
    end 
  else 
    error('The field R.m does not exist.') 
  end 
  if isfield(R,'l') 
    l = R.l; 
    if (l<0) 
      error('Illegal value for number of outputs in R.l') 
    end 
  else 
    error('The field R.l does not exist.') 
  end 
  if isfield(R,'i') 
    i = R.i; 
    if (i<3) 
      error('Illegal value for the block matrix parameter in R.i') 
    end 
  else 
    error('The field R.i does not exist.') 
  end 
  if isfield(R,'Un') 
    Un = R.Un; 
    il  =  i * l; 
    if ~(all(size(Un)==[il,il])) 
      error('The field R.Un has wrong size.') 
    end 
  else 
      error('The field R.Un does not exist.') 
    end 
  end 
 
 
Hheight = 2 * i * (m+l); 
 if isstruct(R) 
  if isfield(R,'L') 
    L = R.L; 
    if ~(all(size(L)==[Hheight,Hheight])) 
      error('R.L has unexpected size.') 
    end 
  else 
      error('The field R.L does not exist.') 
  end 
else 
  error('R should be a structure, generated by dordxx.') 
end 
 
 
 if (n>i * l) 
  error(['The order is too large. It should be smaller than i times #outputs.l']) 
end 
 
 
 
 
 
 
 
 
if nargin==5 
   % Method of Haverkamp et. al. 
Uhi = L(1:m * i,1:(2 * m+l) * i+l); %Uf hankel matrix 
Uhip1 = L(m+1:m * i,1:(2 * m+l) * i+l); %Uf- hankel matrix 
Lu = L(1:m,1:(2 * m+l) * i+l); %U(i) 
Ly = L((2 * m+l) * i+1:(2 * m+l) * i+l,1:(2 * m+l) * i+l); %Y(i) 
Zi = [L((2 * m+l) * i+1:(2 * m+2 * l) * i,1:(2 * m+l) * i) zeros(i * l,l)]; 
%Zi is the projection of Yf onto Yp, Up, Uf 
Zip1 =  L((2 * m+l) * i+l+1:(2 * m+2 * l) * i,1:(2 * m+l) * i+l); 
 
Gi = [C]; 
Hi = [D]; 
CAn = C; 
for j = 1:i-1 
  CAn = CAn * A; 
  Hi = [D,zeros(l,j * m);Gi * B,Hi]; 
  Gi = [Gi;CAn]; 
end 
Gim1 = Gi(1:(i-1) * l,:); 
Him1 = Hi(1:(i-1) * l,1:(i-1) * m); 
 
Xi = Gi \(Zi-Hi * Uhi); 
Xip1 = Gim1 \(Zip1-Him1 * Uhip1); 
 
resid = [Xip1;Ly]-[A,B;C,D] * [Xi;Lu]; 
SOL     =  resid * resid'; 
Qw       =  SOL(1:n,1:n); 
Swv       =  SOL(1:n,n+1:n+l); 
Rv       =  SOL(n+1:n+l,n+1:n+l); 
[X,L,K] = dare(A',C',Qw,Rv,Swv); 
K = K'; 
 
 
 
 
elseif nargin==3 
   % Method of van overschee et.al (does not require B and D) 
L1 = L(1:m * i,1:m * i); 
L2 = L((2 * m+l) * i+1:2 * (m+l) * i,1:(2 * m+l) * i+l); 
Zip1    =  L2(l+1:i * l,1:(2 * m+l) * i+l); 
Zi      =  [L2(1:i * l,1:(2 * m+l) * i) zeros(i * l,l)]; 
Gam     =  Un(:,1:n); 
LHS     =  [Gam(1:(i-1) * l,1:n)\ Zip1;L2(1:l,1:(2 * m+l) * i+l)]; 
RHS     =  [Gam \ Zi  ;[L1 zeros(m * i,(m+l) * i+l)]]; 
K       =  LHS/RHS; 
Resid   =  LHS - K * RHS; 
% Qw,Rv,Swv matrices 
SOL     =  Resid * Resid'; 
Qw       =  SOL(1:n,1:n); 
Swv       =  SOL(1:n,n+1:n+l); 
Rv       =  SOL(n+1:n+l,n+1:n+l); 
[X,L,K] = dare(A',C',Qw,Rv,Swv); 
K = K'; 
 
 
 
 
end 
 
 

